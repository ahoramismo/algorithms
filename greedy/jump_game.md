# Jump Game

**난이도:** Medium  
**문제 링크:** [LeetCode - Jump Game](https://leetcode.com/problems/jump-game/)

## 문제 설명

정수 배열 `nums`가 주어집니다. 처음에는 배열의 첫 번째 인덱스에 위치하며, 배열의 각 요소는 해당 위치에서의 최대 점프 길이를 나타냅니다.

마지막 인덱스에 도달할 수 있으면 `true`를 반환하고, 그렇지 않으면 `false`를 반환하세요.

## 제약 조건

- `1 <= nums.length <= 10⁴`
- `0 <= nums[i] <= 10⁵`

## 예제

### 예제 1
**입력:** `nums = [2,3,1,1,4]`  
**출력:** `true`  
**설명:** 인덱스 0에서 1로 1칸 점프한 다음, 인덱스 1에서 마지막 인덱스로 3칸 점프합니다.

### 예제 2
**입력:** `nums = [3,2,1,0,4]`  
**출력:** `false`  
**설명:** 어떤 방법을 사용하더라도 항상 인덱스 3에 도달합니다. 인덱스 3의 최대 점프 길이는 0이므로 마지막 인덱스에 도달할 수 없습니다.

## 솔루션

### 코드
```javascript
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function (nums) {
  let maxJump = 0;
  for (let i = 0; i < nums.length; i++) {
    if (i > maxJump) return false;
    maxJump = Math.max(maxJump, i + nums[i]);
  }
  return true;
};
```

### 접근 방법

**그리디 알고리즘**을 사용합니다.

1. 최대 점프 길이를 0으로 초기화합니다.
2. 배열을 순회합니다.
3. 현재 인덱스가 최대 점프 길이보다 크면 `false`를 반환합니다 (도달할 수 없음).
4. 최대 점프 길이를 현재 최대 점프 길이와 현재 인덱스에 값을 더한 값 중 최대값으로 업데이트합니다.
5. 배열을 순회한 후 `true`를 반환합니다.

**핵심 아이디어:** 각 위치에서 도달할 수 있는 최대 인덱스를 추적합니다. 현재 인덱스가 이전 위치들에서 도달할 수 있는 최대 인덱스보다 크면, 그 위치에 도달할 수 없으므로 `false`를 반환합니다.

### 시간 복잡도
**`O(n)`**

- 배열을 한 번 순회하므로 `O(n)`입니다.

### 공간 복잡도
**`O(1)`**

- 추가 공간을 사용하지 않습니다.

