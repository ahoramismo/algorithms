# Reverse Bits

**난이도:** Easy  
**문제 링크:** [LeetCode - Reverse Bits](https://leetcode.com/problems/reverse-bits/)

## 문제 설명

주어진 32비트 부호 없는 정수(unsigned integer)의 비트를 거꾸로 뒤집는 문제입니다.

## 제약 조건

- 입력은 32비트 부호 없는 정수입니다.
- 입력이 `n`일 때, 출력도 32비트 부호 없는 정수로 표현 가능해야 합니다.

## 예제

### 예제 1
**입력:** `n = 43261596` (`00000010100101000001111010011100`)  
**출력:** `964176192` (`00111001011110000010100101000000`)  
**설명:** 입력 이진 문자열 `00000010100101000001111010011100`은 부호 없는 정수 43261596을 나타내므로, 이진 표현이 `00111001011110000010100101000000`인 964176192를 반환합니다.

### 예제 2
**입력:** `n = 2147483644` (`01111111111111111111111111111100`)  
**출력:** `1073741822` (`00111111111111111111111111111110`)  
**설명:** 입력 이진 문자열 `01111111111111111111111111111100`은 부호 없는 정수 2147483644를 나타내므로, 이진 표현이 `00111111111111111111111111111110`인 1073741822를 반환합니다.

## 솔루션

### 코드
```javascript
/**
 * @param {number} n
 * @return {number}
 */
var reverseBits = function (n) {
  let result = 0;

  for (let i = 0; i < 32; i++) {
    result = (result << 1) | (n & 1);
    n = n >>> 1;
  }
  return result;
};
```

### 접근 방법

**비트 조작**을 사용하여 비트를 하나씩 뒤집습니다.

1. 결과를 0으로 초기화합니다.
2. 32번 반복합니다:
   - 결과를 왼쪽으로 1비트 시프트합니다.
   - 입력의 최하위 비트(`n & 1`)를 결과의 최하위 비트에 추가합니다.
   - 입력을 오른쪽으로 1비트 시프트합니다 (부호 없는 시프트 `>>>` 사용).

**핵심 아이디어:** 32비트 정수의 비트를 오른쪽에서 왼쪽으로 하나씩 꺼내서, 결과에 왼쪽에서 오른쪽으로 다시 채워 넣는 방식입니다.

### 시간 복잡도
**`O(1)`**

- 항상 32번 반복하므로 상수 시간입니다.

### 공간 복잡도
**`O(1)`**

- 추가 공간을 사용하지 않습니다.

