# Final Prices With a Special Discount in a Shop

**난이도:** Easy  
**문제 링크:** [LeetCode - Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/)

## 문제 설명

가게에서 특별 할인을 제공합니다. `prices` 배열이 주어지면, 각 상품에 대해 다음 규칙에 따라 최종 가격을 계산하세요:

- 각 상품에 대해 오른쪽에 있는 상품 중 현재 상품의 가격보다 작거나 같은 첫 번째 상품을 찾습니다.
- 그런 상품이 있으면 현재 상품의 가격에서 그 상품의 가격을 할인합니다.
- 그런 상품이 없으면 할인 없이 원래 가격을 유지합니다.

최종 가격 배열을 반환하세요.

## 제약 조건

- `1 <= prices.length <= 500`
- `1 <= prices[i] <= 10³`

## 예제

### 예제 1
**입력:** `prices = [8,4,6,2,3]`  
**출력:** `[4,2,4,2,3]`  
**설명:** 
- 상품 0의 가격은 8이고, 오른쪽에서 4(인덱스 1)가 첫 번째로 작거나 같은 가격입니다. 최종 가격 = 8 - 4 = 4
- 상품 1의 가격은 4이고, 오른쪽에서 2(인덱스 3)가 첫 번째로 작거나 같은 가격입니다. 최종 가격 = 4 - 2 = 2
- 상품 2의 가격은 6이고, 오른쪽에서 2(인덱스 3)가 첫 번째로 작거나 같은 가격입니다. 최종 가격 = 6 - 2 = 4
- 상품 3의 가격은 2이고, 오른쪽에 작거나 같은 가격이 없습니다. 최종 가격 = 2
- 상품 4의 가격은 3이고, 오른쪽에 상품이 없습니다. 최종 가격 = 3

### 예제 2
**입력:** `prices = [1,2,3,4,5]`  
**출력:** `[1,2,3,4,5]`  
**설명:** 오른쪽에 작거나 같은 가격이 없으므로 할인이 적용되지 않습니다.

### 예제 3
**입력:** `prices = [10,1,1,6]`  
**출력:** `[9,0,1,6]`  
**설명:**
- 상품 0의 가격은 10이고, 오른쪽에서 1(인덱스 1)이 첫 번째로 작거나 같은 가격입니다. 최종 가격 = 10 - 1 = 9
- 상품 1의 가격은 1이고, 오른쪽에서 1(인덱스 2)이 첫 번째로 작거나 같은 가격입니다. 최종 가격 = 1 - 1 = 0
- 상품 2의 가격은 1이고, 오른쪽에 작거나 같은 가격이 없습니다. 최종 가격 = 1
- 상품 3의 가격은 6이고, 오른쪽에 상품이 없습니다. 최종 가격 = 6

## 솔루션

### 코드
```javascript
/**
 * @param {number[]} prices
 * @return {number[]}
 */
var finalPrices = function (prices) {
    const result = [...prices];
    const stack = [];

    for (let i = 0; i < prices.length; i++) {
        while (stack.length > 0 && prices[stack.at(-1)] >= prices[i]) {
            result[stack.pop()] -= prices[i];
        }

        stack.push(i);
    }

    return result;
};
```

### 접근 방법

**모노톤 스택(Monotonic Stack)**을 사용합니다.

1. 결과 배열을 원래 가격으로 초기화합니다.
2. 스택을 사용하여 아직 할인을 적용받지 못한 상품의 인덱스를 저장합니다.
3. 배열을 순회하면서:
   - 현재 가격이 스택의 맨 위 인덱스의 가격보다 작거나 같으면, 스택에서 pop하여 해당 인덱스의 가격에서 현재 가격을 할인합니다.
   - 현재 인덱스를 스택에 push합니다.

**핵심 아이디어:** 스택을 사용하여 오른쪽에서 작거나 같은 첫 번째 가격을 효율적으로 찾습니다. 스택에는 가격이 내림차순으로 유지되며, 현재 가격이 스택의 가격보다 작거나 같으면 할인을 적용할 수 있습니다.

### 시간 복잡도
**`O(n)`**

- 각 요소는 최대 한 번 스택에 push되고 한 번 pop되므로 `O(n)`입니다.

### 공간 복잡도
**`O(n)`**

- 스택과 결과 배열에 `O(n)` 공간이 필요합니다.