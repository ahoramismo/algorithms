# Minimum Operations to Convert All Elements to Zero

**난이도:** Medium (추정)  
**문제 링크:** [LeetCode - Minimum Operations to Convert All Elements to Zero](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/)

## 문제 설명

정수 배열 `nums`가 주어집니다. 배열의 모든 요소를 0으로 만드는 최소 연산 횟수를 구하세요.

각 연산은 다음과 같이 정의됩니다:
- 배열의 특정 구간을 선택하여 해당 구간의 모든 요소를 0으로 만들 수 있습니다.
- 단, 연산의 효율성을 위해 **증가하는 부분 수열(increasing subsequence)**을 형성하는 구간만 선택할 수 있습니다.

구체적으로, 배열을 순회하면서 **증가하는 부분 수열**의 개수를 세면, 그것이 필요한 최소 연산 횟수입니다.

## 제약 조건

- `1 <= nums.length <= 10⁵`
- `0 <= nums[i] <= 10⁹`

## 예제

### 예제 1
**입력:** `nums = [1,2,3,2,1]`  
**출력:** `2`  
**설명:**
- 첫 번째 증가하는 부분 수열: `[1,2,3]`
- 두 번째 증가하는 부분 수열: `[2]` (또는 `[1]`)
- 따라서 최소 2번의 연산이 필요합니다.

### 예제 2
**입력:** `nums = [3,2,1,0]`  
**출력:** `4`  
**설명:** 각 요소가 독립적인 증가하는 부분 수열이므로 4번의 연산이 필요합니다.

### 예제 3
**입력:** `nums = [1,1,1,1]`  
**출력:** `1`  
**설명:** 모든 요소가 같은 값이므로 하나의 증가하는 부분 수열로 처리할 수 있습니다.

## 솔루션

### 코드
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
const minOperations = nums => {
    const stk = [];
    let res = 0;
    
    for (const n of nums) {
        // 스택에서 현재 값보다 큰 값들을 제거 (내림차순 유지)
        while (stk.length && stk.at(-1) > n) {
            stk.pop();
        }
        
        // 0은 건너뜀
        if (n === 0) {
            continue;
        }
        
        // 스택이 비어있거나 스택의 top이 현재 값보다 작으면
        // 새로운 증가하는 부분 수열의 시작
        if (!stk.length || stk.at(-1) < n) {
            res++;
            stk.push(n);
        }
    }
    
    return res;
};
```

### 접근 방법

**스택(Stack)**을 사용하여 증가하는 부분 수열의 개수를 효율적으로 계산합니다.

1. **스택을 사용한 내림차순 유지**: 스택을 순회하면서 현재 값보다 큰 값들을 제거합니다. 이렇게 하면 스택에는 항상 내림차순으로 정렬된 값들만 남습니다.
2. **증가하는 부분 수열 감지**: 
   - 스택이 비어있거나 스택의 top이 현재 값보다 작으면, 새로운 증가하는 부분 수열이 시작됩니다.
   - 이 경우 카운트를 증가시키고 현재 값을 스택에 push합니다.
   - 스택의 top이 현재 값과 같으면, 같은 부분 수열에 포함시킬 수 있으므로 카운트를 증가시키지 않습니다.
3. **0 처리**: 0은 건너뛰어 처리합니다.

**핵심 아이디어:** 스택을 사용하여 각 위치에서 "이전에 본 값들 중 현재 값보다 작은 최대값"을 추적합니다. 이를 통해 증가하는 부분 수열의 개수를 효율적으로 계산할 수 있습니다.

### 시간 복잡도
**`O(n)`**

- 각 요소는 최대 한 번 스택에 push되고 한 번 pop되므로 `O(n)`입니다.

### 공간 복잡도
**`O(n)`**

- 스택에 최대 `O(n)` 공간이 필요합니다.


